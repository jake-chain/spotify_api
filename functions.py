import jsonimport osimport timeimport apiimport files# Executa um comando passado por parâmetrodef exe_commant(commant, user):    if commant == "update_tracks":        user.set_tracks(update_tracks(user.get_user_id(), user.get_token()))        return True    elif commant == "update_playlists":        user.set_playlists(update_playlists(user.get_user_id(), user.get_token()))        return True    elif commant == "show_tracks":        print("Função ainda não finalizada")    elif commant == "show_playlists":        print("Função ainda não finalizada")    elif commant == "exit":        print("Encerrando execução")        exit()    elif commant == "delete":        print("Excluindo arquivos do usuário")        files.delete_data(user.get_user_id())    elif commant == "help":        print("Ajuda")    else:        print("Comando inválido")        exe_commant("help", user)# Nessa função, é recebido um dict de objects e retorna em formato de dict de dict# Ou seja, ele converte os objects do dict em dictdef convert_objects_to_dict(list_objects: dict) -> dict:    # Varipavel usada para armazenar o retorno da função    converted_data = {}    # Percorrendo o dict para capturar os objects    for key, current_object in list_objects.items():        # Convetendo o object para dict        converted_data[key] = current_object.__dict__    # Retorno da função    return converted_data# Atualiza o arquivo de músicasdef update_tracks(user_id, token) -> dict or bool:    try:        tracks = api.get_tracks_api(token)        # Salvando no arquivo os dados        file_tracks = files.open_file(f"./storage/{user_id}/tracks.dat", 'w')        file_tracks.write(json.dumps(convert_objects_to_dict(tracks)))        file_tracks.close()        return tracks    except Exception as e:        return get_error(e)# Atualiza o arquivo de playlists e músicas em playlistsdef update_playlists(user_id, token) -> dict or bool:    try:        # Consultando todas as playlists        playlists = api.get_playlists_api(user_id, token)        # Consultando as músicas das playlists        for playlist in playlists:            current_tracks_playlist = api.get_tracks_by_playlist_api(playlist.playlists_id, token)            playlist.tracks(current_tracks_playlist)            print("Encontradas {} músicas na playlists {}".format(len(current_tracks_playlist), playlist.name))        # Salvando no arquivo os dados        file_playlists = files.open_file(f"./storage/{user_id}/playlists.dat", 'w')        file_playlists.write(json.dumps(convert_objects_to_dict(playlists)))        file_playlists.close()        return playlists    except Exception as e:        return get_error(e)# Tratamento de erros e geração do arquivo de logdef get_error(erro) -> bool:    file_log = files.open_file('logs', 'a')    file_log.write("Hora: " + time.strftime("%H:%M:%S") + "\nError: " + str(erro) + "\n\n")    file_log.close()    # for_delete    # Exibição da mensagem para teste    print("\nErro capturado na execução do serviço.\n{}\n".format(str(erro)))    return False# Apenas limpa o terminaldef clear_terminal():    os.system('CLS') if os.name == 'nt' else os.system('clear')